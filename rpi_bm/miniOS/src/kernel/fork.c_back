#include "mm.h"
#include "mem.h"
#include "sched.h"
#include "fork.h"
#include "entry.h"
#include "printf.h"
#define PF_KTHREAD		            	0x00000002
extern pg_dir;
int copy_process_inkernel(unsigned long fn, unsigned long arg)
{
	preempt_disable();
	struct task_struct *p;

	p = (struct task_struct *) get_free_pages(1);
	if (!p)
		return 1;
	p->priority = current->priority;
	p->state = TASK_RUNNING;
	p->counter = p->priority;
	p->preempt_count = 1; //disable preemtion until schedule_tail

	p->cpu_context.x19 = fn;
	p->cpu_context.x20 = arg;
	p->cpu_context.pc = (unsigned long)ret_from_fork;
	p->cpu_context.sp = (unsigned long)p + THREAD_SIZE;
	int pid = nr_tasks++;
	task[pid] = p;	
	preempt_enable();
	return 0;
}
int copy_process(unsigned long clone_flags, unsigned long fn, unsigned long arg, unsigned long stack)
{

	
	printf("first in copy_process%x\n\r",fn);
	preempt_disable();
	struct task_struct *p;
	unsigned long page = allocate_kernel_page();
	printf("allocate_kernel_page in copy_process%x\n\r",page);
	p = (struct task_struct *)page ;
	if (!p) {
		printf("Error while get_free_pages in copy_process\n\r");
		return -1;
	}

	/**/
	unsigned long kernel_stack = allocate_kernel_page(); // 分配内核栈
    if (!kernel_stack) {
        printf("Failed to allocate kernel stack\n\r");
      //  free_kernel_page(page); // 释放已分配的task_struct
        return -1;
    }
	p->stack = kernel_stack; // 所有任务都设置内核栈指针
    printf("Allocated kernel stack at 0x%x\n\r", kernel_stack);

	// 2. 初始化内存管理
    if (clone_flags & PF_KTHREAD) {
        // 内核线程不需要用户页表
        p->mm = 0;
    } else {
        // 用户进程需要完整的页表
        p->mm = (struct mm_struct *)allocate_kernel_page();
        if (!p->mm)return -1;
        memzero(p->mm,  sizeof(struct mm_struct));
        
        p->mm->pgd = alloc_new_pgd();
        if (!p->mm->pgd)return -1;
        
        // 复制内核映射并初始化用户空间
		 u64 kernel_pgd = kernel_pgd_addr();
		 	 p->mm->pgd = allocate_kernel_page();
        copy_kernel_mappings(p->mm->pgd, kernel_pgd);
       // if (init_user_mappings(p->mm->pgd, 0x0, 0x8000000) != 0)
		//printf("error  init_user_mappings \r\n");
         //   goto user_mapping_fail;
    }


	struct pt_regs *childregs = task_pt_regs(p);
	memzero((unsigned long)childregs, sizeof(struct pt_regs));
	memzero((unsigned long)&p->cpu_context, sizeof(struct cpu_context));
	//printf("after  memzero in copy_process\n\r");
	
	if (clone_flags & PF_KTHREAD) {
		p->cpu_context.x19 = fn;
		p->cpu_context.x20 = arg;
	} else {
		struct pt_regs * cur_regs = task_pt_regs(current);
		*childregs=	*cur_regs; 	
		childregs->regs[0] = 0;
		childregs->sp = stack + PAGE_SIZE; 
		p->stack = stack;
		printf("else in copy_process\n\r");
	}
	
	p->flags = clone_flags;
	p->priority = current->priority;
	p->state = TASK_RUNNING;
	p->counter = p->priority=1;
	p->preempt_count = 1; //disable preemtion until schedule_tail

	p->cpu_context.pc = (unsigned long)ret_from_fork;
	p->cpu_context.sp = (unsigned long)childregs;
	int pid = nr_tasks++;
	task[pid] = p;	
	printf("before return in copy_process,ret_from_fork=%x,childregs=%x ,p=%x\r\n",ret_from_fork,childregs,p);
	preempt_enable();

	return pid;
}

/*
int move_to_user_mode(unsigned long start, unsigned long size, unsigned long pc)
{
	struct pt_regs *regs = task_pt_regs(current);
	regs->pstate = PSR_MODE_EL0t;
	regs->pc = pc;
	regs->sp = 2 *  PAGE_SIZE;  
	unsigned long code_page = allocate_user_page(current, 0);
	if (code_page == 0)	{
		return -1;
	}
	memcpy(code_page, start, size);
	set_pgd(current->mm.pgd);
	return 0;
}
*/
static inline bool is_aligned(unsigned long addr, unsigned long align)
{
    return !(addr & (align - 1));
}

/*
int move_to_user_mode(unsigned long start, unsigned long size, unsigned long pc)
{
	//irq_disable();
	printf(" in move_to_user_mode\r\n");
	struct pt_regs *regs = task_pt_regs(current);
	regs->pstate = PSR_MODE_EL0t;
	regs->pc = pc;
	regs->sp = 2 *  PAGE_SIZE;  
	unsigned long code_page = allocate_user_page(current, 0);
	printf(" code_page %x\r\n",code_page);
	if (code_page == 0)	{
		return -1;
	}
	memcpy(code_page, start, size);
	printf(" before set_pgd\r\n");
	printf("current->mm.pgd %x", current->mm.pgd);
	if (!current->mm.pgd || !is_aligned(current->mm.pgd, PAGE_SIZE)) {
    printf("Invalid pgd: %p", current->mm.pgd);
	}

	set_pgd(current->mm.pgd);
		printf(" after set_pgd\r\n");
//irq_enable();
	return 0;
}
	*/

int move_to_user_mode(unsigned long start, unsigned long size, unsigned long pc)
{
	
printf(" in move_to_user_mode\n\r");
    
    if (size > PAGE_SIZE || !start || !pc) {
        return -1;
    }
  
    struct pt_regs *regs = task_pt_regs(current);
    
    unsigned long code_page = allocate_user_page(current, pc & PAGE_MASK, PTE_VALID | PTE_USER  );
    if (!code_page) {
        return -1;
    }
    
  
    unsigned long stack_page = allocate_user_page(current, 0, PTE_VALID | PTE_USER | PTE_WRITE|PTE_UXN  ); // User-writable, no execute);
    if (!stack_page) {
        free_page(code_page - VA_START);
        return -1;
    }
    printf(" after  allocate stack_page %x \n\r",stack_page);
 
    memcpy((void*)code_page, (void*)start, size);
     

    regs->pstate = PSR_MODE_EL0t;  
    regs->pc = pc;                
    regs->sp = stack_page + USER_STACK_SIZE; 



	debug_pgd(current->mm->pgd);
    set_pgd(current->mm->pgd);
    return 0;
}

pgd_t *copy_kernel_mappings(pgd_t *dest_pgd,pgd_t *src_pgd) {
    // 分配新的顶级页表
    pgd_t *new_pgd =dest_pgd;// (pgd_t *)allocate_kernel_page();
    if (!new_pgd) {
        printf("Failed to allocate new PGD\n\r");
        return 0;
    }
    memzero(new_pgd, PAGE_SIZE);

    // 内核空间在ARM64中通常使用TTBR1，地址范围从PAGE_OFFSET开始
    unsigned long kernel_start = 0x80000;
    unsigned long kernel_end = (unsigned long)(-1);

    // 复制内核空间映射
    for (unsigned long addr = kernel_start; addr < kernel_end; addr += PGDIR_SIZE) {
        int pgd_idx = pgd_index(addr);
        pgd_t pgd = src_pgd[pgd_idx];
        
      
    }

    // 复制固定映射区域（如设备映射）
    // 这里需要根据你的具体架构添加

    printf("Copied kernel mappings from 0x%lx to 0x%lx\n\r", (unsigned long)src_pgd, (unsigned long)new_pgd);
    return new_pgd;
}

void debug_pgd(pgd_t *pgd) {
    for (int i = 0; i < 5; i++) { // 打印前5项
        printf("pgd[%d] = 0x%x\n", i, pgd[i]);
    }
}



struct pt_regs * task_pt_regs(struct task_struct *tsk){
	unsigned long p = (unsigned long)tsk->stack + THREAD_SIZE - sizeof(struct pt_regs);
	return (struct pt_regs *)p;
}


#include "mm.h"

#include "sysregs.h"
#include "mmu.h"
#define PTRS_PER_TABLE			(1 << TABLE_SHIFT)
#define PGD_SHIFT			PAGE_SHIFT + 3*TABLE_SHIFT
#define PUD_SHIFT			PAGE_SHIFT + 2*TABLE_SHIFT
#define PMD_SHIFT			PAGE_SHIFT + TABLE_SHIFT
#define VA_START 			KERNEL_VIRT_OFFSET
#define PG_DIR_SIZE			(3 * PAGE_SIZE)
#define DEVICE_BASE 0x3F000000  // Raspberry Pi 外设基地址
#define PHYS_MEMORY_SIZE 		0x40000000	
.section ".text.boot"

.globl _start
_start:
    mrs x0, mpidr_el1
    and x0, x0, #0xFF
    cbz x0, master
    b proc_hang

master:
    ldr x0, =SCTLR_VALUE_MMU_DISABLED
    msr sctlr_el1, x0

    ldr x0, =HCR_VALUE
    msr hcr_el2, x0

    ldr x0, =SCR_VALUE
    msr scr_el3, x0

    ldr x0, =SPSR_VALUE
    msr spsr_el3, x0

#if INIT_MMU == 1
    ldr x0, =CPACR_EL1_VAL
    msr CPACR_EL1, x0

    ldr x0, =TCR_EL1_VAL
    msr TCR_EL1, x0

    ldr x0, =MAIR_VALUE
    msr MAIR_EL1, x0
#endif

    adr x0, el1_entry
    msr elr_el3, x0

    eret

el1_entry:
    mov sp, #LOW_MEMORY

    adr x0, KERNEL_BSS_START
    adr x1, KERNEL_BSS_END
    sub x1, x1, x0
    bl memzero

#if INIT_MMU == 1
    bl init_mmu
    bl 	__create_page_tables
    //bl init_kernel_mmu


    adrp x0, id_pgd
    msr ttbr0_el1, x0
    
    adrp x0, pg_dir
    msr ttbr1_el1, x0
    

ldr	x2, =kernel_main
    mrs x0, sctlr_el1
    mov x1, #SCTLR_MMU_ENABLED
    orr x0, x0, x1
    msr sctlr_el1, x0
#endif
br 	x2
   // bl kernel_main
    b  proc_hang




    
proc_hang:
    wfe
    b proc_hang

.globl id_pgd_addr
id_pgd_addr:
    adrp x0, id_pgd
    ret

.globl kernel_pgd_addr
kernel_pgd_addr:
    adrp x0, pg_dir
    ret




.macro	create_pgd_entry, tbl, virt, tmp1, tmp2
	create_table_entry \tbl, \virt, PGD_SHIFT, \tmp1, \tmp2
	create_table_entry \tbl, \virt, PUD_SHIFT, \tmp1, \tmp2
.endm

.macro	create_table_entry, tbl, virt, shift, tmp1, tmp2
	lsr	\tmp1, \virt, #\shift
	and	\tmp1, \tmp1, #PTRS_PER_TABLE - 1			// table index
	add	\tmp2, \tbl, #PAGE_SIZE
	orr	\tmp2, \tmp2, #MM_TYPE_PAGE_TABLE	
	str	\tmp2, [\tbl, \tmp1, lsl #3]
	add	\tbl, \tbl, #PAGE_SIZE					// next level table page
.endm

	.macro	create_block_map, tbl, phys, start, end, flags, tmp1
	lsr	\start, \start, #SECTION_SHIFT
	and	\start, \start, #PTRS_PER_TABLE - 1			// table index
	lsr	\end, \end, #SECTION_SHIFT
	and	\end, \end, #PTRS_PER_TABLE - 1				// table end index
	lsr	\phys, \phys, #SECTION_SHIFT
	mov	\tmp1, #\flags
	orr	\phys, \tmp1, \phys, lsl #SECTION_SHIFT			// table entry
9999:	str	\phys, [\tbl, \start, lsl #3]				// store the entry
	add	\start, \start, #1					// next entry
	add	\phys, \phys, #SECTION_SIZE				// next block
	cmp	\start, \end
	b.ls	9999b
	.endm

__create_page_tables:
	mov	x29, x30						// save return address

	adrp	x0, pg_dir
	mov	x1, #PG_DIR_SIZE
	bl 	memzero

	adrp	x0, pg_dir
	mov	x1, #VA_START 
	create_pgd_entry x0, x1, x2, x3

	/* Mapping kernel and init stack*/
	mov 	x1, xzr							// start mapping from physical offset 0
	mov 	x2, #VA_START						// first virtual address
	ldr	x3, =(VA_START + DEVICE_BASE - SECTION_SIZE)		// last virtual address
	create_block_map x0, x1, x2, x3, MMU_FLAGS, x4

	/* Mapping device memory*/
	mov 	x1, #DEVICE_BASE					// start mapping from device base address 
	ldr 	x2, =(VA_START + DEVICE_BASE)				// first virtual address
	ldr	x3, =(VA_START + PHYS_MEMORY_SIZE - SECTION_SIZE)	// last virtual address
	create_block_map x0, x1, x2, x3, MMU_DEVICE_FLAGS, x4
     // 4. 刷新 TLB 和缓存
    dsb	sy
    tlbi	vmalle1is
    dsb	sy
    isb

	mov	x30, x29						// restore return address
	ret
